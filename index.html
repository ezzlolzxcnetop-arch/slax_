<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Slax_</title>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js';
        import { getDatabase, ref, onValue, set, update, push } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js';

        // Your Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyAHkdr6tAaUplSieZuK8r7bVu62tJPLjII",
            authDomain: "slax-chat.firebaseapp.com",
            projectId: "slax-chat",
            storageBucket: "slax-chat.firebasestorage.app",
            messagingSenderId: "1045228942622",
            appId: "1:1045228942622:web:2b6e94819ea912edd0c50f"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
    </script>
    <style>
        body {
            background-color: #222;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #main {
            display: flex;
            height: calc(100% - 60px);
        }
        #sidebar {
            width: 30%;
            border-right: 1px solid #0f0;
            padding: 10px;
            overflow-y: auto;
        }
        #search {
            background: transparent;
            color: #0f0;
            border: none;
            width: 100%;
            font-size: 16px;
        }
        #chat {
            width: 70%;
            padding: 10px;
            overflow-y: auto;
        }
        #input-area {
            position: fixed;
            bottom: 0;
            left: 30%;
            width: 70%;
            background: #111;
            border-top: 1px solid #0f0;
            padding: 5px;
            display: flex;
            align-items: center;
        }
        #message-input {
            background: transparent;
            color: #0f0;
            border: none;
            flex: 1;
            font-size: 16px;
            outline: none;
        }
        .button {
            color: #0f0;
            background: transparent;
            border: 1px solid #0f0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            margin: 0 5px;
            padding: 2px 6px;
        }
        .voice-recording {
            color: #f00;
        }
        .audio-player {
            display: inline-block;
            margin-left: 10px;
        }
        .call-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .call-notification {
            background: #333;
            padding: 10px;
            border: 1px solid #f00;
            margin: 5px 0;
        }
        .screen-video {
            width: 100%;
            max-width: 300px;
            margin: 5px 0;
        }
        .local-video {
            width: 100px;
            height: 75px;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 20;
        }
        .auth-input {
            background: transparent;
            color: #0f0;
            border: none;
            display: block;
            margin: 5px 0;
            width: 100%;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="main">
        <div id="sidebar">
            <input id="search" placeholder="> search friends...">
            <div id="profile">
                > my profile <button id="logout" class="button">logout</button>
                <div id="my-id"></div>
            </div>
            <div id="pending-requests">
                > Pending requests:
                <div id="pending-list"></div>
            </div>
            <div id="friends-list">
                > no friends
            </div>
        </div>
        <div id="chat">
            > select friend start chatting...
        </div>
    </div>
    <div id="input-area">
        <input id="message-input" placeholder="> type message...">
        <button id="record-btn" class="button">mic</button>
        <button id="call-btn" class="button" style="display: none;">call</button>
        <span id="record-status"></span>
    </div>

    <script type="module">
        import { getDatabase, ref, onValue, set, update, push, get } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js';

        const db = getDatabase();
        let currentUser = localStorage.getItem('currentUser');
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let callStream = null;
        let screenStream = null;
        let screenVideo = null;
        let localVideo = null;
        let peerConnection = null;
        let dataChannel = null;
        let userData = {}; // Local cache
        let selectedFriend = null;

        // Inactivity check (local)
        const lastVisitKey = 'slax_lastVisit';
        let lastVisit = parseInt(localStorage.getItem(lastVisitKey)) || 0;
        const now = Date.now();
        const THREE_DAYS = 3 * 24 * 60 * 60 * 1000;
        if (currentUser && now - lastVisit > THREE_DAYS) {
            localStorage.removeItem('currentUser');
            currentUser = null;
        }
        localStorage.setItem(lastVisitKey, now.toString());

        function saveUserData(userId, data) {
            const updates = {};
            updates[`users/${userId}`] = data;
            update(ref(db), updates);
        }

        function showLogin() {
            document.getElementById('chat').innerHTML = `
> Login to Slax_
<input id="username" class="auth-input" placeholder="> username">
<input id="password" type="password" class="auth-input" placeholder="> password">
<button id="auth-btn" class="button">login</button>
<div style="margin-top:10px;">
<button id="toggle-auth" class="button">register</button>
</div>
            `;
            let authMode = 'login';
            document.getElementById('auth-btn').onclick = async () => {
                const user = document.getElementById('username').value.trim();
                const pass = document.getElementById('password').value.trim();
                if (!user || !pass) return alert('> Enter username and password');
                const userRef = ref(db, `users/${user}`);
                const snapshot = await get(userRef);
                const userData = snapshot.val();
                if (authMode === 'login') {
                    if (!userData || userData.password !== pass) return alert('> Invalid credentials');
                    localStorage.setItem('currentUser', user);
                    currentUser = user;
                    localStorage.setItem(lastVisitKey, now.toString());
                    initApp();
                } else {
                    if (userData) return alert('> User exists');
                    set(userRef, {
                        password: pass,
                        friends: [],
                        pendingRequests: [],
                        messages: {},
                        callStates: {}
                    });
                    localStorage.setItem('currentUser', user);
                    currentUser = user;
                    localStorage.setItem(lastVisitKey, now.toString());
                    initApp();
                }
            };
            document.getElementById('toggle-auth').onclick = () => {
                authMode = authMode === 'login' ? 'register' : 'login';
                document.getElementById('auth-btn').textContent = authMode;
                document.getElementById('toggle-auth').textContent = authMode === 'login' ? 'register' : 'login';
            };
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('input-area').style.display = 'none';
        }

        function initApp() {
            document.getElementById('sidebar').style.display = 'block';
            document.getElementById('input-area').style.display = 'flex';
            document.getElementById('my-id').innerText = `> ID: ${currentUser}`;
            document.getElementById('logout').onclick = () => {
                localStorage.removeItem('currentUser');
                location.reload();
            };

            const userRef = ref(db, `users/${currentUser}`);
            onValue(userRef, (snapshot) => {
                userData = snapshot.val() || {};
                refreshAll();
            });

            refreshFriends();

            // Text message
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && selectedFriend) {
                    const msg = e.target.value.trim();
                    if (msg) {
                        sendMessage(msg, 'text');
                    }
                    e.target.value = '';
                }
            });

            // Voice recording
            const recordBtn = document.getElementById('record-btn');
            const recordStatus = document.getElementById('record-status');
            recordBtn.onclick = async () => {
                if (!selectedFriend) return alert('> Select a friend first');
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            };

            async function startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.readAsDataURL(audioBlob);
                        reader.onloadend = () => {
                            const base64data = reader.result;
                            sendMessage(base64data, 'voice');
                        };
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.classList.add('voice-recording');
                    recordBtn.textContent = 'stop';
                    recordStatus.textContent = '> recording...';
                } catch (err) {
                    alert('> Microphone access denied or not available');
                }
            }

            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordBtn.classList.remove('voice-recording');
                    recordBtn.textContent = 'mic';
                    recordStatus.textContent = '';
                }
            }

            // Call button
            const callBtn = document.getElementById('call-btn');
            callBtn.onclick = async () => {
                if (!selectedFriend) return alert('> Select a friend first');
                const myCallStateRef = ref(db, `users/${currentUser}/callStates/${selectedFriend}`);
                const snapshot = await get(myCallStateRef);
                const myCallState = snapshot.val() || {status: 'ended'};
                if (myCallState.status === 'ended') {
                    const updates = {};
                    updates[`users/${currentUser}/callStates/${selectedFriend}`] = {status: 'calling', mic: true, screen: false};
                    updates[`users/${selectedFriend}/callStates/${currentUser}`] = {status: 'incoming', mic: false, screen: false};
                    update(ref(db), updates);
                    alert(`> Calling ${selectedFriend}...`);
                } else if (myCallState.status === 'active') {
                    endCall();
                }
            };

            function endCall() {
                if (selectedFriend) {
                    const updates = {};
                    updates[`users/${currentUser}/callStates/${selectedFriend}`] = {status: 'ended', mic: true, screen: false};
                    updates[`users/${selectedFriend}/callStates/${currentUser}`] = {status: 'ended', mic: false, screen: false};
                    update(ref(db), updates);
                    stopLocalStreams();
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnection = null;
                    }
                    if (dataChannel) {
                        dataChannel.close();
                        dataChannel = null;
                    }
                    callBtn.textContent = 'call';
                    if (localVideo) {
                        localVideo.remove();
                        localVideo = null;
                    }
                    refreshChat();
                }
            }

            function stopLocalStreams() {
                if (callStream) {
                    callStream.getTracks().forEach(track => track.stop());
                    callStream = null;
                }
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
                if (screenVideo) {
                    screenVideo.remove();
                    screenVideo = null;
                }
            }

            // Search friends
            document.getElementById('search').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const searchUser = e.target.value.trim();
                    get(ref(db, 'users')).then(snapshot => {
                        const allUsers = snapshot.val();
                        if (searchUser && searchUser !== currentUser && allUsers[searchUser]) {
                            get(ref(db, `users/${currentUser}/friends`)).then(fSnap => {
                                const friends = fSnap.val() || [];
                                if (!friends.includes(searchUser)) {
                                    get(ref(db, `users/${currentUser}/pendingRequests`)).then(pSnap => {
                                        const pending = pSnap.val() || [];
                                        if (!pending.includes(searchUser)) {
                                            const updates = {};
                                            const friendPending = allUsers[searchUser].pendingRequests || [];
                                            updates[`users/${searchUser}/pendingRequests`] = [...friendPending, currentUser];
                                            update(ref(db), updates);
                                            alert(`> Friend request sent to ${searchUser}`);
                                        } else {
                                            alert('> Request pending');
                                        }
                                    });
                                } else {
                                    alert('> Already friends');
                                }
                            });
                        } else {
                            alert('> User not found');
                        }
                        e.target.value = '';
                    });
                }
            });
        }

        function sendMessage(content, type) {
            if (!selectedFriend) return;
            const messageObj = {
                from: currentUser,
                type: type,
                content: content,
                time: new Date().toISOString()
            };
            const updates = {};
            if (!userData.messages[selectedFriend]) userData.messages[selectedFriend] = [];
            userData.messages[selectedFriend].push(messageObj);
            updates[`users/${currentUser}/messages/${selectedFriend}`] = userData.messages[selectedFriend];

            if (!userData.messages[currentUser]) userData.messages[currentUser] = [];
            userData.messages[currentUser].push(messageObj);
            updates[`users/${selectedFriend}/messages/${currentUser}`] = userData.messages[currentUser];

            update(ref(db), updates);
            refreshChat();
        }

        function refreshAll() {
            refreshFriends();
            if (selectedFriend) refreshChat();
        }

        function refreshFriends() {
            const fl = document.getElementById('friends-list');
            const friends = userData.friends || [];
            if (friends.length === 0) {
                fl.innerHTML = '> no friends';
            } else {
                fl.innerHTML = friends.map(f => `<div class="friend" data-user="${f}" style="cursor: pointer;">> ${f}</div>`).join('');
                document.querySelectorAll('.friend').forEach(el => {
                    el.onclick = () => {
                        selectedFriend = el.dataset.user;
                        document.getElementById('call-btn').style.display = 'block';
                        refreshChat();
                        document.getElementById('message-input').focus();
                    };
                });
            }

            const pl = document.getElementById('pending-list');
            const pending = userData.pendingRequests || [];
            if (pending.length === 0) {
                pl.innerHTML = '';
            } else {
                pl.innerHTML = pending.map(p => `
> ${p} <button class="button accept" data-user="${p}">accept</button> <button class="button decline" data-user="${p}">decline</button>
                `).join('');
                document.querySelectorAll('.accept').forEach(btn => {
                    btn.onclick = async () => {
                        const u = btn.dataset.user;
                        const updates = {};
                        const myFriends = [...(userData.friends || []), u];
                        updates[`users/${currentUser}/friends`] = myFriends;
                        const friendData = await get(ref(db, `users/${u}`));
                        const friendFriends = [...(friendData.val().friends || []), currentUser];
                        updates[`users/${u}/friends`] = friendFriends;
                        const myPending = (userData.pendingRequests || []).filter(x => x !== u);
                        updates[`users/${currentUser}/pendingRequests`] = myPending;
                        update(ref(db), updates);
                    };
                });
                document.querySelectorAll('.decline').forEach(btn => {
                    btn.onclick = async () => {
                        const u = btn.dataset.user;
                        const myPending = (userData.pendingRequests || []).filter(x => x !== u);
                        const updates = { [`users/${currentUser}/pendingRequests`]: myPending };
                        update(ref(db), updates);
                    };
                });
            }
        }

        function refreshChat() {
            if (!selectedFriend) {
                document.getElementById('chat').innerHTML = '> select friend start chatting...';
                return;
            }
            const msgs = userData.messages[selectedFriend] || [];
            let html = `> Chat with ${selectedFriend}<br>` + 
                msgs.map(m => {
                    if (m.type === 'text') {
                        return `> ${m.from}: ${m.content}`;
                    } else if (m.type === 'voice') {
                        return `> ${m.from}: [VOICE] <audio controls class="audio-player" src="${m.content}"></audio>`;
                    }
                    return '';
                }).join('<br>');

            const callState = userData.callStates[selectedFriend] || {status: 'none'};
            const friendCallRef = ref(db, `users/${selectedFriend}/callStates/${currentUser}`);
            get(friendCallRef).then(snapshot => {
                const friendCallState = snapshot.val() || {status: 'none'};

                if (callState.status === 'calling') {
                    html += `<div class="call-notification">> Calling ${selectedFriend}... <button class="button" onclick="endCall()">End</button></div>`;
                    document.getElementById('call-btn').textContent = 'end';
                } else if (friendCallState.status === 'calling') {
                    html += `<div class="call-notification">> Incoming call from ${selectedFriend}! <button class="button" onclick="acceptCall()">Accept</button> <button class="button" onclick="rejectCall()">Reject</button></div>`;
                } else if (callState.status === 'active') {
                    html += `<div class="call-notification">> Call active with ${selectedFriend}</div>`;
                    html += `<div class="call-controls">
> Mic: <button class="button" id="mic-toggle-btn" style="color: ${callState.mic ? '#0f0' : '#f00'}">${callState.mic ? 'mute' : 'unmute'}</button>
> Screen: <button class="button" id="screen-toggle-btn" style="color: ${callState.screen ? '#0f0' : '#f00'}">${callState.screen ? 'stop share' : 'share'}</button>
> <button class="button" onclick="endCall()">End Call</button>
</div>`;
                    setTimeout(() => {
                        document.getElementById('mic-toggle-btn').onclick = toggleMic;
                        document.getElementById('screen-toggle-btn').onclick = toggleScreen;
                    }, 0);
                    document.getElementById('call-btn').textContent = 'end';
                } else {
                    document.getElementById('call-btn').textContent = 'call';
                }

                if (callState.screen && screenVideo) {
                    html += screenVideo.outerHTML;
                }

                document.getElementById('chat').innerHTML = html;
                document.getElementById('chat').scrollTop = document.getElementById('chat').scrollHeight;
            });
        }

        // Call functions (simplified for Firebase)
        window.acceptCall = async () => {
            if (selectedFriend) {
                const updates = {};
                updates[`users/${currentUser}/callStates/${selectedFriend}`] = {status: 'active', mic: true, screen: false};
                updates[`users/${selectedFriend}/callStates/${currentUser}`] = {status: 'active', mic: true, screen: false};
                update(ref(db), updates);
                await startLocalCall();
                refreshChat();
            }
        };

        window.rejectCall = () => {
            if (selectedFriend) {
                const updates = {};
                updates[`users/${selectedFriend}/callStates/${currentUser}`] = {status: 'ended', mic: false, screen: false};
                update(ref(db), updates);
                refreshChat();
            }
        };

        window.endCall = () => endCall();

        async function startLocalCall() {
            try {
                callStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                localVideo = document.createElement('video');
                localVideo.srcObject = callStream;
                localVideo.autoplay = true;
                localVideo.muted = true;
                localVideo.className = 'local-video';
                document.body.appendChild(localVideo);

                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                callStream.getTracks().forEach(track => peerConnection.addTrack(track, callStream));

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) console.log('> ICE candidate');
                };

                peerConnection.ontrack = (event) => {
                    console.log('> Remote stream');
                };

                dataChannel = peerConnection.createDataChannel('control');
                dataChannel.onopen = () => console.log('> Data channel open');
                dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log(`> Remote ${data.type} ${data.enabled ? 'on' : 'off'}`);
                };

                console.log('> Call started');
            } catch (err) {
                alert('> Mic denied');
            }
        }

        function toggleMic() {
            if (selectedFriend && callStream) {
                const newMic = !userData.callStates[selectedFriend].mic;
                const updates = {};
                updates[`users/${currentUser}/callStates/${selectedFriend}/mic`] = newMic;
                updates[`users/${selectedFriend}/callStates/${currentUser}/mic`] = newMic;
                update(ref(db), updates);

                const audioTrack = callStream.getAudioTracks()[0];
                if (audioTrack) audioTrack.enabled = newMic;

                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'mic', enabled: newMic }));
                }

                refreshChat();
            }
        }

        async function toggleScreen() {
            if (selectedFriend) {
                const newScreen = !userData.callStates[selectedFriend].screen;
                if (newScreen) {
                    try {
                        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                        screenVideo = document.createElement('video');
                        screenVideo.srcObject = screenStream;
                        screenVideo.autoplay = true;
                        screenVideo.muted = true;
                        screenVideo.className = 'screen-video';

                        if (peerConnection) {
                            screenStream.getTracks().forEach(track => peerConnection.addTrack(track, screenStream));
                        }

                        const updates = {};
                        updates[`users/${currentUser}/callStates/${selectedFriend}/screen`] = true;
                        updates[`users/${selectedFriend}/callStates/${currentUser}/screen`] = true;
                        update(ref(db), updates);

                        if (dataChannel && dataChannel.readyState === 'open') {
                            dataChannel.send(JSON.stringify({ type: 'screen', enabled: true }));
                        }

                        refreshChat();
                    } catch (err) {
                        alert('> Screen denied');
                    }
                } else {
                    stopLocalStreams();
                    const updates = {};
                    updates[`users/${currentUser}/callStates/${selectedFriend}/screen`] = false;
                    updates[`users/${selectedFriend}/callStates/${currentUser}/screen`] = false;
                    update(ref(db), updates);

                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(JSON.stringify({ type: 'screen', enabled: false }));
                    }
                    refreshChat();
                }
            }
        }

        // Init
        if (!currentUser) {
            showLogin();
        } else {
            get(ref(db, `users/${currentUser}`)).then(snapshot => {
                if (!snapshot.exists()) {
                    localStorage.removeItem('currentUser');
                    showLogin();
                } else {
                    initApp();
                }
            });
        }
    </script>
</body>
</html>

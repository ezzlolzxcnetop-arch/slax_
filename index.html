<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Slax_</title>
    <style>
        body {
            background-color: #222;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #main {
            display: flex;
            height: calc(100% - 60px); /* for input + voice bar */
        }
        #sidebar {
            width: 30%;
            border-right: 1px solid #0f0;
            padding: 10px;
            overflow-y: auto;
        }
        #search {
            background: transparent;
            color: #0f0;
            border: none;
            width: 100%;
            font-size: 16px;
        }
        #chat {
            width: 70%;
            padding: 10px;
            overflow-y: auto;
        }
        #input-area {
            position: fixed;
            bottom: 0;
            left: 30%;
            width: 70%;
            background: #111;
            border-top: 1px solid #0f0;
            padding: 5px;
            display: flex;
            align-items: center;
        }
        #message-input {
            background: transparent;
            color: #0f0;
            border: none;
            flex: 1;
            font-size: 16px;
            outline: none;
        }
        .button {
            color: #0f0;
            background: transparent;
            border: 1px solid #0f0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            margin: 0 5px;
            padding: 2px 6px;
        }
        .voice-recording {
            color: #f00;
        }
        .audio-player {
            display: inline-block;
            margin-left: 10px;
        }
        .call-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .call-notification {
            background: #333;
            padding: 10px;
            border: 1px solid #f00;
            margin: 5px 0;
        }
        .screen-video {
            width: 100%;
            max-width: 300px;
            margin: 5px 0;
        }
        .local-video {
            width: 100px;
            height: 75px;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 20;
        }
        .auth-input {
            background: transparent;
            color: #0f0;
            border: none;
            display: block;
            margin: 5px 0;
            width: 100%;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="main">
        <div id="sidebar">
            <input id="search" placeholder="> search friends...">
            <div id="profile">
                > my profile <button id="logout" class="button">logout</button>
                <div id="my-id"></div>
            </div>
            <div id="pending-requests">
                > Pending requests:
                <div id="pending-list"></div>
            </div>
            <div id="friends-list">
                > no friends
            </div>
        </div>
        <div id="chat">
            > select friend start chatting...
        </div>
    </div>
    <div id="input-area">
        <input id="message-input" placeholder="> type message...">
        <button id="record-btn" class="button">mic</button>
        <button id="call-btn" class="button" style="display: none;">call</button>
        <span id="record-status"></span>
    </div>

    <script>
        let currentUser = localStorage.getItem('currentUser');
        const usersKey = 'slax_users';
        const lastVisitKey = 'slax_lastVisit';
        let users = JSON.parse(localStorage.getItem(usersKey)) || {};
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let callStream = null;
        let screenStream = null;
        let screenVideo = null;
        let localVideo = null;
        let peerConnection = null;
        let dataChannel = null;

        // Check inactivity
        let lastVisit = parseInt(localStorage.getItem(lastVisitKey)) || 0;
        const now = Date.now();
        const THREE_DAYS = 3 * 24 * 60 * 60 * 1000;
        if (currentUser && now - lastVisit > THREE_DAYS) {
            console.log('> Сессия сброшена из-за неактивности >3 дней');
            localStorage.removeItem('currentUser');
            currentUser = null;
        }
        localStorage.setItem(lastVisitKey, now.toString());

        function saveUsers() {
            localStorage.setItem(usersKey, JSON.stringify(users));
        }

        function showLogin() {
            console.log('> Показываем экран авторизации');
            document.getElementById('chat').innerHTML = `
> Login to Slax_
<input id="username" class="auth-input" placeholder="> username">
<input id="password" type="password" class="auth-input" placeholder="> password">
<button id="auth-btn" class="button">login</button>
<div style="margin-top:10px;">
<button id="toggle-auth" class="button">register</button>
</div>
            `;
            let authMode = 'login';
            document.getElementById('auth-btn').onclick = () => {
                const user = document.getElementById('username').value.trim();
                const pass = document.getElementById('password').value.trim();
                if (!user || !pass) return alert('> Enter username and password');
                if (authMode === 'login') {
                    if (!users[user] || users[user].password !== pass) return alert('> Invalid credentials');
                    localStorage.setItem('currentUser', user);
                    currentUser = user;
                    localStorage.setItem(lastVisitKey, now.toString());
                    console.log(`> Логин успешен для ${user}`);
                    initApp();
                } else {
                    if (users[user]) return alert('> User exists');
                    users[user] = {
                        password: pass,
                        friends: [],
                        pendingRequests: [],
                        messages: {},
                        callStates: {}
                    };
                    saveUsers();
                    localStorage.setItem('currentUser', user);
                    currentUser = user;
                    localStorage.setItem(lastVisitKey, now.toString());
                    console.log(`> Регистрация успешен для ${user}`);
                    initApp();
                }
            };
            document.getElementById('toggle-auth').onclick = () => {
                authMode = authMode === 'login' ? 'register' : 'login';
                document.getElementById('auth-btn').textContent = authMode;
                document.getElementById('toggle-auth').textContent = authMode === 'login' ? 'register' : 'login';
            };
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('input-area').style.display = 'none';
        }

        let selectedFriend = null;

        function initApp() {
            console.log(`> Инициализация app для ${currentUser}`);
            document.getElementById('sidebar').style.display = 'block';
            document.getElementById('input-area').style.display = 'flex';
            document.getElementById('my-id').innerText = `> ID: ${currentUser}`;
            document.getElementById('logout').onclick = () => {
                console.log('> Логаут');
                localStorage.removeItem('currentUser');
                location.reload();
            };

            // Ensure callStates
            if (!users[currentUser].callStates) {
                users[currentUser].callStates = {};
            }

            refreshFriends();

            // Text message
            document.getElementById('message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && selectedFriend) {
                    const msg = e.target.value.trim();
                    if (msg) {
                        sendMessage(msg, 'text');
                    }
                    e.target.value = '';
                }
            });

            // Voice recording
            const recordBtn = document.getElementById('record-btn');
            const recordStatus = document.getElementById('record-status');

            recordBtn.onclick = async () => {
                if (!selectedFriend) return alert('> Select a friend first');
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            };

            async function startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = e => {
                        audioChunks.push(e.data);
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.readAsDataURL(audioBlob);
                        reader.onloadend = () => {
                            const base64data = reader.result;
                            sendMessage(base64data, 'voice');
                        };
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.classList.add('voice-recording');
                    recordBtn.textContent = 'stop';
                    recordStatus.textContent = '> recording...';
                } catch (err) {
                    alert('> Microphone access denied or not available');
                }
            }

            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordBtn.classList.remove('voice-recording');
                    recordBtn.textContent = 'mic';
                    recordStatus.textContent = '';
                }
            }

            // Call button
            const callBtn = document.getElementById('call-btn');
            callBtn.onclick = () => {
                if (!selectedFriend) return alert('> Select a friend first');
                if (!users[currentUser].callStates[selectedFriend]) {
                    users[currentUser].callStates[selectedFriend] = {status: 'calling', mic: true, screen: false};
                    users[selectedFriend].callStates[currentUser] = {status: 'incoming', mic: false, screen: false};
                    saveUsers();
                    alert(`> Calling ${selectedFriend}...`);
                } else if (users[currentUser].callStates[selectedFriend].status === 'active') {
                    // End call
                    endCall();
                }
            };

            function endCall() {
                if (selectedFriend) {
                    users[currentUser].callStates[selectedFriend] = {status: 'ended', mic: true, screen: false};
                    users[selectedFriend].callStates[currentUser] = {status: 'ended', mic: false, screen: false};
                    saveUsers();
                    stopLocalStreams();
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnection = null;
                    }
                    if (dataChannel) {
                        dataChannel.close();
                        dataChannel = null;
                    }
                    callBtn.textContent = 'call';
                    if (localVideo) {
                        localVideo.remove();
                        localVideo = null;
                    }
                }
            }

            function stopLocalStreams() {
                if (callStream) {
                    callStream.getTracks().forEach(track => track.stop());
                    callStream = null;
                }
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
                if (screenVideo) {
                    screenVideo.remove();
                    screenVideo = null;
                }
            }

            // Search friends
            document.getElementById('search').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const searchUser = e.target.value.trim();
                    if (searchUser && searchUser !== currentUser && users[searchUser]) {
                        if (!users[currentUser].friends.includes(searchUser) && 
                            !users[searchUser].pendingRequests.includes(currentUser)) {
                            users[searchUser].pendingRequests.push(currentUser);
                            saveUsers();
                            alert(`> Friend request sent to ${searchUser}`);
                        } else {
                            alert('> Already friends or request pending');
                        }
                    } else {
                        alert('> User not found or invalid');
                    }
                    e.target.value = '';
                }
            });

            setInterval(refreshAll, 1000); // Faster polling for calls
        }

        function sendMessage(content, type) {
            if (!selectedFriend) return;

            const messageObj = {
                from: currentUser,
                type: type,
                content: content,
                time: new Date().toISOString()
            };

            if (!users[currentUser].messages[selectedFriend]) {
                users[currentUser].messages[selectedFriend] = [];
            }
            users[currentUser].messages[selectedFriend].push(messageObj);

            if (!users[selectedFriend].messages[currentUser]) {
                users[selectedFriend].messages[currentUser] = [];
            }
            users[selectedFriend].messages[currentUser].push(messageObj);

            saveUsers();
            refreshChat();
        }

        function refreshAll() {
            users = JSON.parse(localStorage.getItem(usersKey)) || {};
            refreshFriends();
            if (selectedFriend) refreshChat();
        }

        function refreshFriends() {
            const fl = document.getElementById('friends-list');
            const friends = users[currentUser]?.friends || [];
            if (friends.length === 0) {
                fl.innerHTML = '> no friends';
            } else {
                fl.innerHTML = friends.map(f => `<div class="friend" data-user="${f}" style="cursor: pointer;">> ${f}</div>`).join('');
                document.querySelectorAll('.friend').forEach(el => {
                    el.onclick = () => {
                        selectedFriend = el.dataset.user;
                        document.getElementById('call-btn').style.display = 'block';
                        refreshChat();
                        document.getElementById('message-input').focus();
                    };
                });
            }

            const pl = document.getElementById('pending-list');
            const pending = users[currentUser]?.pendingRequests || [];
            if (pending.length === 0) {
                pl.innerHTML = '';
            } else {
                pl.innerHTML = pending.map(p => `
> ${p} <button class="button accept" data-user="${p}">accept</button> <button class="button decline" data-user="${p}">decline</button>
                `).join('');
                document.querySelectorAll('.accept').forEach(btn => {
                    btn.onclick = () => {
                        const u = btn.dataset.user;
                        users[currentUser].friends.push(u);
                        users[u].friends.push(currentUser);
                        users[currentUser].pendingRequests = users[currentUser].pendingRequests.filter(x => x !== u);
                        saveUsers();
                        refreshFriends();
                    };
                });
                document.querySelectorAll('.decline').forEach(btn => {
                    btn.onclick = () => {
                        const u = btn.dataset.user;
                        users[currentUser].pendingRequests = users[currentUser].pendingRequests.filter(x => x !== u);
                        saveUsers();
                        refreshFriends();
                    };
                });
            }
        }

        function refreshChat() {
            if (!selectedFriend) {
                document.getElementById('chat').innerHTML = '> select friend start chatting...';
                return;
            }
            const chat = document.getElementById('chat');
            const msgs = users[currentUser]?.messages[selectedFriend] || [];
            let html = `> Chat with ${selectedFriend}<br>` + 
                msgs.map(m => {
                    if (m.type === 'text') {
                        return `> ${m.from}: ${m.content}`;
                    } else if (m.type === 'voice') {
                        return `> ${m.from}: [VOICE] <audio controls class="audio-player" src="${m.content}"></audio>`;
                    }
                    return '';
                }).join('<br>');

            // Call state
            const callState = users[currentUser]?.callStates[selectedFriend] || {status: 'none'};
            const friendCallState = users[selectedFriend]?.callStates[currentUser] || {status: 'none'};

            if (callState.status === 'calling') {
                html += `<div class="call-notification">> Calling ${selectedFriend}... <button class="button" onclick="endCall()">End</button></div>`;
                document.getElementById('call-btn').textContent = 'end';
            } else if (friendCallState.status === 'incoming') {
                html += `<div class="call-notification">> Incoming call from ${selectedFriend}! <button class="button" onclick="acceptCall()">Accept</button> <button class="button" onclick="rejectCall()">Reject</button></div>`;
            } else if (callState.status === 'active') {
                html += `<div class="call-notification">> Call active with ${selectedFriend}</div>`;
                html += `<div class="call-controls">
> Mic: <button class="button" id="mic-toggle-btn" style="color: ${callState.mic ? '#0f0' : '#f00'}">${callState.mic ? 'mute' : 'unmute'}</button>
> Screen: <button class="button" id="screen-toggle-btn" style="color: ${callState.screen ? '#0f0' : '#f00'}">${callState.screen ? 'stop share' : 'share'}</button>
> <button class="button" onclick="endCall()">End Call</button>
</div>`;
                // Add event listeners for toggles (re-attach on refresh)
                setTimeout(() => {
                    const micBtn = document.getElementById('mic-toggle-btn');
                    if (micBtn) micBtn.onclick = toggleMic;
                    const screenBtn = document.getElementById('screen-toggle-btn');
                    if (screenBtn) screenBtn.onclick = toggleScreen;
                }, 0);
                document.getElementById('call-btn').textContent = 'end';
            } else {
                document.getElementById('call-btn').textContent = 'call';
            }

            // Screen video if sharing
            if (callState.screen && screenVideo) {
                html += screenVideo.outerHTML;
            }

            chat.innerHTML = html;
            chat.scrollTop = chat.scrollHeight;
        }

        // Call functions
        window.acceptCall = async function() {
            if (selectedFriend) {
                users[currentUser].callStates[selectedFriend] = {status: 'active', mic: true, screen: false};
                users[selectedFriend].callStates[currentUser] = {status: 'active', mic: true, screen: false};
                saveUsers();
                await startLocalCall();
            }
        };

        window.rejectCall = function() {
            if (selectedFriend) {
                users[selectedFriend].callStates[currentUser] = {status: 'ended', mic: false, screen: false};
                saveUsers();
            }
        };

        window.endCall = function() {
            endCall();
        };

        async function startLocalCall() {
            try {
                callStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                // Local video preview (optional, for mic activity visualization)
                localVideo = document.createElement('video');
                localVideo.srcObject = callStream;
                localVideo.autoplay = true;
                localVideo.muted = true;
                localVideo.className = 'local-video';
                document.body.appendChild(localVideo);

                // Simulate peer connection (in real app, use STUN/TURN and signaling)
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                // Add local stream to peer
                callStream.getTracks().forEach(track => peerConnection.addTrack(track, callStream));

                // Handle ICE candidates (in real, send via signaling)
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('> ICE candidate generated (send to peer via signaling)');
                    }
                };

                // Handle remote stream (in real, play incoming audio/video)
                peerConnection.ontrack = (event) => {
                    console.log('> Remote stream received (play audio)');
                    // Simulate playing remote audio
                };

                // Create data channel for signaling mic/screen state
                dataChannel = peerConnection.createDataChannel('control');
                dataChannel.onopen = () => console.log('> Data channel open for controls');
                dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'mic') {
                        // Handle remote mic state change
                        console.log(`> Remote mic ${data.enabled ? 'enabled' : 'muted'}`);
                    } else if (data.type === 'screen') {
                        // Handle remote screen share
                        console.log(`> Remote screen ${data.enabled ? 'shared' : 'stopped'}`);
                    }
                };

                console.log('> Local call started with WebRTC peer connection');
            } catch (err) {
                alert('> Microphone access denied for call');
            }
        }

        function toggleMic() {
            if (selectedFriend && callStream) {
                const newMic = !users[currentUser].callStates[selectedFriend].mic;
                users[currentUser].callStates[selectedFriend].mic = newMic;
                users[selectedFriend].callStates[currentUser].mic = newMic; // Sync state
                saveUsers();

                // Real mute/unmute
                const audioTrack = callStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = newMic;
                }

                // Send via data channel (in real signaling)
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'mic', enabled: newMic }));
                }

                refreshChat();
            }
        }

        async function toggleScreen() {
            if (selectedFriend) {
                const newScreen = !users[currentUser].callStates[selectedFriend].screen;
                if (newScreen) {
                    try {
                        screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                        screenVideo = document.createElement('video');
                        screenVideo.srcObject = screenStream;
                        screenVideo.autoplay = true;
                        screenVideo.muted = true;
                        screenVideo.className = 'screen-video';
                        document.getElementById('chat').appendChild(screenVideo);

                        // Add to peer connection
                        if (peerConnection) {
                            screenStream.getTracks().forEach(track => peerConnection.addTrack(track, screenStream));
                        }

                        users[currentUser].callStates[selectedFriend].screen = true;
                        users[selectedFriend].callStates[currentUser].screen = true; // Sync
                        saveUsers();

                        // Send via data channel
                        if (dataChannel && dataChannel.readyState === 'open') {
                            dataChannel.send(JSON.stringify({ type: 'screen', enabled: true }));
                        }
                    } catch (err) {
                        alert('> Screen share denied');
                    }
                } else {
                    stopLocalStreams();
                    users[currentUser].callStates[selectedFriend].screen = false;
                    users[selectedFriend].callStates[currentUser].screen = false;
                    saveUsers();

                    // Send via data channel
                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(JSON.stringify({ type: 'screen', enabled: false }));
                    }
                }
                refreshChat();
            }
        }

        // Init
        console.log(`> Проверка сессии: currentUser = ${currentUser}, lastVisit = ${lastVisit}`);
        if (!currentUser) {
            showLogin();
        } else {
            if (!users[currentUser]) {
                console.log('> Аккаунт не найден, сбрасываем сессию');
                localStorage.removeItem('currentUser');
                showLogin();
            } else {
                initApp();
            }
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLAX_TERMINAL_V5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, setDoc, doc, query, onSnapshot, serverTimestamp, getDocs, where, limit, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyC5IfNWuv-8lR5PGvM-5zXxLap3EVa6rDk",
            authDomain: "myconsolechat.firebaseapp.com",
            projectId: "myconsolechat",
            storageBucket: "myconsolechat.firebasestorage.app",
            messagingSenderId: "686599654568",
            appId: "1:686599654568:web:2c190df85c4f7780ca069d",
            measurementId: "G-7B38TF6NH7"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = 'slax-console-v1'; 

        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ]
        };

        let localSessionId = sessionStorage.getItem('slax_session_id');
        if (!localSessionId) {
            localSessionId = crypto.randomUUID();
            sessionStorage.setItem('slax_session_id', localSessionId);
        }
        
        let currentUser = null; 
        let currentUsername = "GUEST"; 
        let authMode = 'login'; 
        let currentChannel = "main";
        let messagesUnsubscribe = null; 
        
        let localStream = null;
        let screenStream = null;
        let isSharingScreen = false;
        let screenSenders = {};

        let currentVoiceChannel = null;

        const peerConnections = {};
        let voiceSessionUnsubscribe = null;
        let signalUnsubscribes = {};
        let isMicMuted = false;
        
        let isSidebarOpen = false;

        const loginScreen = document.getElementById('login-screen');
        const mainInterface = document.getElementById('main-interface');
        const usernameInput = document.getElementById('username-input');
        const pinInput = document.getElementById('pin-input');
        const authMainBtn = document.getElementById('auth-main-btn');
        const authSwitchBtn = document.getElementById('auth-switch-btn');
        const authModeTitle = document.getElementById('auth-mode-title');
        const loginError = document.getElementById('login-error');
        const chatContainer = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const displayUsername = document.getElementById('display-username');
        const displayUid = document.getElementById('display-uid');
        const voiceStatusPanel = document.getElementById('voice-status-panel');
        const currentVoiceName = document.getElementById('current-voice-name');
        const micToggleButton = document.getElementById('mic-toggle-btn');
        const screenToggleButton = document.getElementById('screen-toggle-btn');
        const notificationArea = document.getElementById('notification-area'); 
        const sidebar = document.getElementById('sidebar'); 
        const sidebarBackdrop = document.getElementById('sidebar-backdrop'); 
        const floatingVideosContainer = document.getElementById('floating-videos-container');

        window.toggleSidebar = function() {
            isSidebarOpen = !isSidebarOpen;
            if (isSidebarOpen) {
                sidebar.classList.remove('-translate-x-full');
                sidebar.classList.add('translate-x-0');
                sidebarBackdrop.classList.remove('hidden');
            } else {
                sidebar.classList.remove('translate-x-0');
                sidebar.classList.add('-translate-x-full');
                sidebarBackdrop.classList.add('hidden');
            }
        }
        
        async function initAuth() {
            try {
                await signInAnonymously(auth);
            } catch (e) {
                console.error("SLAX AUTH ERROR:", e);
                loginError.textContent = "КРИТИЧЕСКАЯ ОШИБКА: СБОЙ АВТОРИЗАЦИИ FIREBASE.";
            }
        }
        initAuth();

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                displayUid.textContent = `SID: ${localSessionId.slice(0, 8).toUpperCase()}`; 
                loginError.textContent = "СОЕДИНЕНИЕ УСТАНОВЛЕНО. ВВЕДИТЕ ДАННЫЕ.";
            }
        });

        authMainBtn.addEventListener('click', handleAuthAction);
        authSwitchBtn.addEventListener('click', toggleAuthMode);
        pinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleAuthAction();
        });
        
        function toggleAuthMode() {
            authMode = authMode === 'login' ? 'register' : 'login';
            if (authMode === 'login') {
                authModeTitle.textContent = ">> LOG IN REQUIRED";
                authMainBtn.textContent = "[ CONNECT ]";
                authSwitchBtn.textContent = "[ SWITCH TO REGISTER ]";
            } else {
                authModeTitle.textContent = ">> REGISTER NEW USER";
                authMainBtn.textContent = "[ CREATE USER ]";
                authSwitchBtn.textContent = "[ SWITCH TO LOG IN ]";
            }
            loginError.textContent = "ВВЕДИТЕ ДАННЫЕ.";
            playTone(1500, 0.05);
        }

        function handleAuthAction() {
            if (authMode === 'login') {
                attemptLogin();
            } else {
                attemptRegistration();
            }
        }

        async function validateInput(name, pin) {
            if (!currentUser) {
                loginError.textContent = "ОШИБКА: АВТОРИЗАЦИЯ FIREBASE ОЖИДАЕТСЯ.";
                return false;
            }
            if (!name || name.length < 3 || name.length > 12) {
                loginError.textContent = "ОШИБКА: НИКНЕЙМ ДОЛЖЕН БЫТЬ 3-12 СИМВОЛОВ.";
                return false;
            }
            if (!pin || pin.length !== 4 || isNaN(pin)) {
                loginError.textContent = "ОШИБКА: ПИН ДОЛЖЕН БЫТЬ 4 ЦИФРЫ.";
                return false;
            }
            return true;
        }

        async function attemptLogin() {
            const name = usernameInput.value.trim().toUpperCase();
            const pin = pinInput.value.trim();
            
            if (!await validateInput(name, pin)) return;

            loginError.textContent = "АУТЕНТИФИКАЦИЯ...";
            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'app_users');
            const q = query(usersRef, where('username', '==', name), limit(1));
            
            try {
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    loginError.textContent = "ОШИБКА: ПОЛЬЗОВАТЕЛЬ НЕ НАЙДЕН. ЗАРЕГИСТРИРУЙТЕСЬ.";
                    playTone(200, 0.3);
                    return;
                }
                
                const userData = snapshot.docs[0].data();
                if (userData.pin === pin) {
                    currentUsername = name;
                    grantAccess();
                } else {
                    loginError.textContent = "ОШИБКА: ПИН-КОД НЕВЕРЕН.";
                    playTone(200, 0.3);
                }

            } catch (err) {
                console.error("DB Login Error:", err);
                loginError.textContent = "КРИТИЧЕСКАЯ ОШИБКА БД: СМ. КОНСОЛЬ.";
            }
        }

        async function attemptRegistration() {
            const name = usernameInput.value.trim().toUpperCase();
            const pin = pinInput.value.trim();
            
            if (!await validateInput(name, pin)) return;

            loginError.textContent = "ПОПЫТКА РЕГИСТРАЦИИ...";
            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'app_users');
            const q = query(usersRef, where('username', '==', name), limit(1));

            try {
                const snapshot = await getDocs(q);

                if (!snapshot.empty) {
                    loginError.textContent = "ОШИБКА: НИКНЕЙМ ЗАНЯТ.";
                    playTone(200, 0.3);
                    return;
                }

                await setDoc(doc(usersRef, name), {
                    username: name,
                    pin: pin,
                    createdAt: serverTimestamp()
                });
                
                currentUsername = name;
                loginError.textContent = `ПОЛЬЗОВАТЕЛЬ ${name} УСПЕШНО СОЗДАН.`;
                grantAccess();

            } catch (err) {
                console.error("DB Registration Error:", err);
                loginError.textContent = "КРИТИЧЕСКАЯ ОШИБКА БД ПРИ РЕГИСТРАЦИИ.";
            }
        }

        function grantAccess() {
            displayUsername.textContent = currentUsername;
            loginScreen.classList.add('hidden');
            mainInterface.classList.remove('hidden');
            switchChannel(currentChannel);
            messageInput.focus();
            playTone(800, 0.1); 
        }

        window.switchChannel = function(channelName) {
            currentChannel = channelName;
            
            document.querySelectorAll('#text-channels li').forEach(li => {
                li.classList.remove('channel-active');
                if (li.dataset.channel === channelName) li.classList.add('channel-active');
            });
            document.getElementById('channel-title').textContent = `>> #${channelName.toUpperCase()}_HUB`;
            
            playTone(1200, 0.05);
            subscribeToMessages();
            
            if (isSidebarOpen && window.innerWidth < 768) {
                toggleSidebar();
            }
        }

        function subscribeToMessages() {
            if (messagesUnsubscribe) messagesUnsubscribe();

            const q = collection(db, 'artifacts', appId, 'public', 'data', 'messages');

            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                const allMessages = [];
                snapshot.forEach(doc => {
                    allMessages.push({ id: doc.id, ...doc.data() });
                });

                const channelMessages = allMessages
                    .filter(m => m.channel === currentChannel)
                    .sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));

                renderMessages(channelMessages);
            }, (error) => {
                console.error("SLAX DATA ERROR:", error);
                if (error.code === 'permission-denied') {
                    addSystemMessage("ОШИБКА: НЕДОСТАТОЧНО ПРАВ. ПРОВЕРЬТЕ ПРАВИЛА FIRESTORE.", true);
                } else {
                    addSystemMessage("ОШИБКА: СОЕДИНЕНИЕ ПРЕРВАНО.", true);
                }
            });
        }

        function renderMessages(messages) {
            const staticMessages = Array.from(chatContainer.querySelectorAll('.system-msg'));
            chatContainer.innerHTML = '';
            staticMessages.forEach(msg => chatContainer.appendChild(msg));
            
            messages.forEach(msg => {
                const div = document.createElement('div');
                const date = msg.timestamp ? new Date(msg.timestamp.seconds * 1000) : new Date();
                const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                const isMe = msg.user === currentUsername;
                
                div.innerHTML = `
                    <div class="hover:bg-green-900/10 p-1 -mx-1 rounded">
                        <span class="timestamp font-mono text-green-700">[${timeStr}]</span>
                        <span class="${isMe ? 'text-green-300 font-bold' : 'text-green-500'}">&lt;${msg.user}&gt;</span>
                        <span class="text-green-100 whitespace-pre-wrap ml-2">${msg.text}</span>
                    </div>
                `;
                chatContainer.appendChild(div);
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function addSystemMessage(text, isError = false) {
            const notification = document.createElement('div');
            notification.className = `notification-item text-sm border-l-4 pl-2 ${isError ? 'text-red-300 border-red-500' : 'text-green-300 border-green-500'}`;
            notification.textContent = `>> СИСТЕМА: ${text}`;
            
            notificationArea.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 200);
            }, 2500); 
        }

        messageInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const text = messageInput.value.trim();
                if (!text) return;
                
                if (!currentUsername || currentUsername === 'GUEST') {
                    addSystemMessage("ОШИБКА: НЕ АВТОРИЗОВАН. ТРЕБУЕТСЯ ВХОД.", true);
                    return;
                }

                messageInput.value = '';
                
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'messages'), {
                        text: text,
                        user: currentUsername,
                        uid: currentUser.uid,
                        channel: currentChannel,
                        timestamp: serverTimestamp()
                    });
                    playTone(600, 0.03);
                } catch (err) {
                    console.error("Send error", err);
                    addSystemMessage("ОШИБКА ОТПРАВКИ.", true);
                }
            }
        });

        const voiceRef = (channel) => collection(db, 'artifacts', appId, 'public', 'data', 'voice_sessions', channel, 'users');
        const signalingCollectionRef = (sessionId) => collection(db, 'artifacts', appId, 'public', 'data', 'voice_signals', sessionId, 'incoming_signals'); 

        window.handleVoiceAction = function(voiceId) {
            if (currentVoiceChannel === voiceId) {
                leaveVoice();
            } else {
                joinVoice(voiceId);
            }
            if (isSidebarOpen && window.innerWidth < 768) {
                toggleSidebar();
            }
        };

        async function joinVoice(voiceId) {
            if (!currentUser) return;
            if (currentVoiceChannel) await leaveVoice();
            
            currentVoiceChannel = voiceId;
            voiceStatusPanel.classList.remove('hidden');
            currentVoiceName.textContent = voiceId.toUpperCase();

            addSystemMessage(`ЗАХВАТ МИКРОФОНА...`);
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                micToggleButton.textContent = 'MIC: ON';
                isMicMuted = false;
                
                await setDoc(doc(voiceRef(voiceId), localSessionId), {
                    username: currentUsername,
                    sessionId: localSessionId,
                    uid: currentUser.uid, 
                    joinedAt: serverTimestamp(),
                    isMicMuted: false
                });

                subscribeToVoiceSession(voiceId);
                subscribeToSignaling();
                
                addSystemMessage(`ГОЛОСОВОЙ УЗЕЛ ${voiceId.toUpperCase()} АКТИВЕН.`);
                playTone(400, 0.1);
                setTimeout(() => playTone(600, 0.2), 150);

            } catch (err) {
                console.error("Ошибка при подключении к GS:", err);
                addSystemMessage("ОШИБКА: НЕ УДАЛОСЬ ЗАХВАТИТЬ МИКРОФОН. ПРОВЕРЬТЕ РАЗРЕШЕНИЯ.", true);
                leaveVoice(); 
            }
        }
        
        window.leaveVoice = async function() {
            if (!currentVoiceChannel) {
                addSystemMessage(`ОШИБКА: ВЫ НЕ ПОДКЛЮЧЕНЫ К ГОЛОСОВОМУ КАНАЛУ.`, true);
                return;
            }
            
            if (isSharingScreen) {
                await stopScreenShare();
            }

            const channelToLeave = currentVoiceChannel; 
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            Object.keys(peerConnections).forEach(sessionId => {
                const pc = peerConnections[sessionId];
                if (pc) pc.close();
                removeMediaWindow(sessionId, true);
                delete peerConnections[sessionId];
                delete screenSenders[sessionId];
            });

            if (voiceSessionUnsubscribe) {
                voiceSessionUnsubscribe();
                voiceSessionUnsubscribe = null;
            }
            
            for (const key in signalUnsubscribes) {
                if(signalUnsubscribes[key]) signalUnsubscribes[key]();
                delete signalUnsubscribes[key];
            }
            signalUnsubscribes = {}; 

            if (channelToLeave) {
                await deleteDoc(doc(voiceRef(channelToLeave), localSessionId)).catch(e => {
                    console.warn("Не удалось удалить сессию (может быть уже удалена):", e);
                });
            }

            currentVoiceChannel = null;
            voiceStatusPanel.classList.add('hidden');
            addSystemMessage(`ГОЛОСОВОЙ УЗЕЛ ОТКЛЮЧЕН.`);
            playTone(300, 0.2);
        }
        
        window.addEventListener('beforeunload', async () => {
            if (currentVoiceChannel) {
                const voiceSessionDocRef = doc(voiceRef(currentVoiceChannel), localSessionId);
                try {
                     fetch(voiceSessionDocRef.path, { method: 'DELETE', keepalive: true });
                } catch(e) { /* Игнорируем ошибки */ }
            }
        });

        function subscribeToVoiceSession(voiceId) {
            if (voiceSessionUnsubscribe) voiceSessionUnsubscribe();
            
            const q = voiceRef(voiceId);
            voiceSessionUnsubscribe = onSnapshot(q, (snapshot) => {
                const users = [];
                const currentPeers = new Set(Object.keys(peerConnections));
                const activePeers = new Set();
                
                snapshot.forEach(doc => {
                    const userData = doc.data();
                    if (userData.sessionId !== localSessionId) { 
                        users.push({ username: userData.username, sessionId: userData.sessionId });
                        activePeers.add(userData.sessionId);
                        
                        const pc = peerConnections[userData.sessionId];

                        if (!pc || pc.connectionState === 'closed' || pc.connectionState === 'failed') {
                            const isInitiator = localSessionId < userData.sessionId;
                            createPeerConnection(userData.sessionId, isInitiator); 
                            addSystemMessage(`ПОЛЬЗОВАТЕЛЬ ${userData.username} ПРИСОЕДИНИЛСЯ.`);
                        }
                    }
                });

                currentPeers.forEach(sessionId => {
                    if (!activePeers.has(sessionId)) {
                        const pc = peerConnections[sessionId];
                        if (pc) pc.close();
                        delete peerConnections[sessionId];
                        delete screenSenders[sessionId];
                        if (signalUnsubscribes[sessionId]) signalUnsubscribes[sessionId]();
                        delete signalUnsubscribes[sessionId];
                        removeMediaWindow(sessionId, true);
                        addSystemMessage(`ПОЛЬЗОВАТЕЛЬ ${sessionId.slice(0, 8).toUpperCase()} ВЫШЕЛ.`);
                    }
                });
                
                const usersHtml = users.map(u => `<div class="text-green-300" data-session-id="${u.sessionId}">>> ${u.username}</div>`).join('');
                const voiceLi = document.querySelector(`li[data-voice="${voiceId}"]`);
                if (voiceLi) {
                    voiceLi.querySelector('.voice-users').innerHTML = usersHtml;
                    voiceLi.querySelector('.voice-count').textContent = users.length + 1; 
                }
                
            }, (err) => console.error("Ошибка подписки на сессию:", err));
        }
        
        function subscribeToSignaling() {
            const q = signalingCollectionRef(localSessionId);
            
            if (signalUnsubscribes['local']) signalUnsubscribes['local']();

            signalUnsubscribes['local'] = onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type !== 'added') return; 

                    const signalDoc = change.doc;
                    const data = signalDoc.data();
                    
                    if (data.senderSessionId === localSessionId) {
                        try { await deleteDoc(signalDoc.ref); } catch(e) { /* ignore */ }
                        return;
                    }

                    if (data.offer) {
                        await handleOffer(data.senderSessionId, data.offer, data.senderUsername);
                    } else if (data.answer) {
                        await handleAnswer(data.senderSessionId, data.answer);
                    } else if (data.candidate) {
                        await handleCandidate(data.senderSessionId, data.candidate);
                    }
                    
                    try {
                        await deleteDoc(signalDoc.ref);
                    } catch (e) {
                        console.error("Ошибка удаления сигнала:", e);
                    }
                });
            }, (err) => console.error("Ошибка подписки на сигналы:", err));
        }

        async function createPeerConnection(targetSessionId, isInitiator) {
            const pc = new RTCPeerConnection(iceServers);
            peerConnections[targetSessionId] = pc;
            
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            if (screenStream && isSharingScreen) {
                const videoTrack = screenStream.getVideoTracks()[0];
                if (videoTrack) {
                    const sender = pc.addTrack(videoTrack, screenStream);
                    screenSenders[targetSessionId] = sender;
                }
                screenStream.getAudioTracks().forEach(track => pc.addTrack(track, screenStream));
            }
            
            pc.ontrack = (event) => {
                const stream = event.streams[0];
                const track = event.track;

                const voiceLi = document.querySelector(`li[data-voice="${currentVoiceChannel}"]`);
                const userDiv = voiceLi ? voiceLi.querySelector(`.voice-users div[data-session-id="${targetSessionId}"]`) : null;
                const targetUsername = userDiv ? userDiv.textContent.replace('>> ', '').trim() : targetSessionId.slice(0, 8).toUpperCase(); 

                if (track.kind === 'audio') {
                    ensureMediaWindow(targetSessionId, targetUsername, stream, 'audio');
                } else if (track.kind === 'video') {
                    ensureMediaWindow(targetSessionId, targetUsername, stream, 'video');
                }
            };

            pc.onnegotiationneeded = async () => {
                if (isInitiator) {
                    try {
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        await sendSignal({
                            offer: pc.localDescription.toJSON(),
                            senderSessionId: localSessionId,
                            senderUsername: currentUsername,
                            type: 'offer'
                        }, targetSessionId);
                    } catch (e) {
                        console.error("Ошибка onnegotiationneeded:", e);
                    }
                }
            };
            
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await sendSignal({
                        candidate: event.candidate.toJSON(),
                        senderSessionId: localSessionId,
                        senderUsername: currentUsername,
                        type: 'candidate'
                    }, targetSessionId);
                }
            };
            
            if (isInitiator) {
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    await sendSignal({
                        offer: pc.localDescription.toJSON(),
                        senderSessionId: localSessionId,
                        senderUsername: currentUsername,
                        type: 'offer'
                    }, targetSessionId);
                } catch (e) {
                    console.error("Ошибка создания OFFER:", e);
                }
            }
        }

        async function handleOffer(senderSessionId, offer, senderUsername) {
            let pc = peerConnections[senderSessionId];
            if (!pc) {
                createPeerConnection(senderSessionId, false);
                pc = peerConnections[senderSessionId];
            }

            try {
                if (pc.signalingState !== 'stable') {
                    if (pc.signalingState === 'have-local-offer') {
                         await pc.setLocalDescription({ type: "rollback" });
                    }
                }
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await sendSignal({
                    answer: pc.localDescription.toJSON(),
                    senderSessionId: localSessionId,
                    senderUsername: currentUsername,
                    type: 'answer'
                }, senderSessionId);
            } catch (e) {
                console.error("ОШИБКА ОБРАБОТКИ OFFER:", e);
            }
        }

        async function handleAnswer(senderSessionId, answer) {
            const pc = peerConnections[senderSessionId];
            if (pc && pc.signalingState === 'have-local-offer') {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(answer));
                } catch (e) {
                    console.error("ОШИБКА ОБРАБОТКИ ANSWER:", e);
                }
            }
        }

        async function handleCandidate(senderSessionId, candidate) {
            const pc = peerConnections[senderSessionId];
            if (pc && pc.remoteDescription) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                    console.error('Ошибка ICE:', e);
                }
            }
        }
        
        async function sendSignal(signalData, targetSessionId) {
            const recipientCollection = signalingCollectionRef(targetSessionId); 
            try {
                await addDoc(recipientCollection, signalData); 
            } catch (e) {
                console.error(`Ошибка отправки сигнала:`, e);
            }
        }
        
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const dragHeader = element.querySelector('.drag-handle');
            const startDrag = dragHeader || element;
            startDrag.onpointerdown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onpointermove = elementDrag;
                document.onpointerup = closeDrag;
            }

            function elementDrag(e) {
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }

            function closeDrag() {
                document.onpointermove = null;
                document.onpointerup = null;
            }
        }

        function ensureMediaWindow(sessionId, username, stream, type, isLocal = false) {
            const windowId = `window-${sessionId}`;
            const mediaId = `${sessionId}-${type}`;
            let windowElement = document.getElementById(windowId);
            
            if (type === 'audio') {
                let audio = document.getElementById(mediaId);
                if (!audio) {
                    audio = document.createElement('audio');
                    audio.id = mediaId;
                    audio.autoplay = true;
                    audio.style.display = 'none';
                    document.body.appendChild(audio);
                }
                audio.srcObject = stream;
                return;
            }

            if (!windowElement) {
                windowElement = document.createElement('div');
                windowElement.id = windowId;
                windowElement.className = "floating-window fixed bg-black/95 border-2 border-green-700 shadow-[0_0_15px_rgba(0,255,0,0.5)] z-50";
                windowElement.style.cssText = `width:280px;height:180px;top:50px;right:50px;min-width:200px;min-height:150px;`;

                const displayName = isLocal ? 'YOUR SCREEN' : `${username}'s SCREEN`;
                windowElement.innerHTML = `
                    <div class="drag-handle p-1.5 cursor-move bg-green-900/50 flex justify-between items-center text-xs font-bold border-b border-green-700">
                        <span class="text-green-300">${isLocal ? '>> ' : '<< '}${displayName}</span>
                        <button onclick="removeMediaWindow('${sessionId}', true)" class="text-red-500 hover:text-red-300">[ X ]</button>
                    </div>
                    <video id="${mediaId}" autoplay playsinline class="w-full h-full object-contain bg-black"></video>
                `;
                floatingVideosContainer.appendChild(windowElement);
                makeDraggable(windowElement);
            }

            const video = windowElement.querySelector('video');
            if (video) {
                video.srcObject = stream;
                stream.getVideoTracks()[0].onended = () => !isLocal && removeMediaWindow(sessionId, true);
            }
        }

        window.removeMediaWindow = function(sessionId, isManual = false) {
            [`${sessionId}-audio`, `window-${sessionId}`].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });
            if (sessionId === localSessionId && isSharingScreen && isManual) {
                stopScreenShare();
            }
        }

        window.toggleMic = function() {
            if (!localStream) return;
            isMicMuted = !isMicMuted;
            localStream.getAudioTracks().forEach(t => t.enabled = !isMicMuted);
            micToggleButton.textContent = isMicMuted ? 'MIC: OFF' : 'MIC: ON';
            addSystemMessage(isMicMuted ? 'МИКРОФОН ВЫКЛЮЧЕН.' : 'МИКРОФОН ВКЛЮЧЕН.');
            playTone(1000, 0.05);
            if (currentVoiceChannel) {
                updateDoc(doc(voiceRef(currentVoiceChannel), localSessionId), { isMicMuted });
            }
        }

        window.toggleScreenShare = async function() {
            if (isSharingScreen) {
                await stopScreenShare();
            } else {
                await startScreenShare();
            }
        }

        async function startScreenShare() {
            if (!currentVoiceChannel) {
                addSystemMessage("СНАЧАЛА ПОДКЛЮЧИСЬ К ГОЛОСОВОМУ КАНАЛУ.", true);
                return;
            }
            if (isSharingScreen) return;

            addSystemMessage("ЗАХВАТ ЭКРАНА...");
            try {
                // Адаптивно для мобильных
                const constraints = {
                    video: { cursor: "always" },
                    audio: false
                };

                // iOS Safari требует audio: false
                if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    constraints.audio = false;
                }

                screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);
                isSharingScreen = true;
                screenToggleButton.textContent = 'SCREEN: ON';
                screenToggleButton.classList.add('bg-green-600');
                screenToggleButton.classList.remove('bg-green-900/20');

                ensureMediaWindow(localSessionId, currentUsername, screenStream, 'video', true);

                Object.keys(peerConnections).forEach(id => {
                    const pc = peerConnections[id];
                    const videoTrack = screenStream.getVideoTracks()[0];
                    if (videoTrack) {
                        const sender = pc.addTrack(videoTrack, screenStream);
                        screenSenders[id] = sender;
                    }
                });

                screenStream.getVideoTracks()[0].onended = stopScreenShare;
                addSystemMessage("ДЕМОНСТРАЦИЯ ЭКРАНА НАЧАТА.");
                playTone(1500, 0.1);

            } catch (e) {
                console.error("Ошибка захвата экрана:", e);
                addSystemMessage("НЕ УДАЛОСЬ ЗАХВАТИТЬ ЭКРАН.", true);
                screenToggleButton.textContent = 'SCREEN: OFF';
            }
        }

        async function stopScreenShare() {
            if (!isSharingScreen || !screenStream) return;

            Object.keys(peerConnections).forEach(id => {
                const sender = screenSenders[id];
                if (sender) peerConnections[id].removeTrack(sender);
                delete screenSenders[id];
            });

            screenStream.getTracks().forEach(t => t.stop());
            screenStream = null;
            removeMediaWindow(localSessionId, false);
            isSharingScreen = false;
            screenToggleButton.textContent = 'SCREEN: OFF';
            screenToggleButton.classList.remove('bg-green-600');
            screenToggleButton.classList.add('bg-green-900/20');
            addSystemMessage("ДЕМОНСТРАЦИЯ ОСТАНОВЛЕНА.");
            playTone(300, 0.1);
        }

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        function playTone(freq, dur) {
            try {
                if (ctx.state === 'suspended') ctx.resume();
                const o = ctx.createOscillator(), g = ctx.createGain();
                o.type = 'square'; o.frequency.value = freq; g.gain.value = 0.03;
                o.connect(g); g.connect(ctx.destination);
                o.start(); o.stop(ctx.currentTime + dur);
            } catch(e) {}
        }
    </script>

    <style>
        :root {
            --terminal-green: #0f0;
            --terminal-bg: #050505;
            --scanline: rgba(0, 255, 0, 0.04);
        }

        body {
            background: var(--terminal-bg);
            color: var(--terminal-green);
            font-family: 'VT323', monospace;
            overflow: hidden;
            text-shadow: 0 0 3px var(--terminal-green);
            font-size: 1.1rem;
        }

        @media (min-width: 768px) { body { font-size: 1.25rem; } }

        .scanlines {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(to bottom, var(--scanline) 50%, transparent 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 50;
        }

        .crt-flicker { animation: flicker 0.15s infinite; opacity: 0.95; }
        @keyframes flicker { 0%, 100% { opacity: 0.97; } 50% { opacity: 0.94; } }

        ::-webkit-scrollbar { width: 12px; }
        ::-webkit-scrollbar-track { background: #001100; }
        ::-webkit-scrollbar-thumb { background: #003300; border: 1px solid #0f0; }
        ::-webkit-scrollbar-thumb:hover { background: #0f0; }

        .channel-active {
            background: rgba(0, 255, 0, 0.2);
            border-left: 4px solid #0f0;
            padding-left: 8px !important;
        }

        .system-msg { color: #88aa88; font-style: italic; font-size: 0.9em; border-left: 2px solid #0f0; }
        .timestamp { opacity: 0.5; margin-right: 10px; font-size: 0.8em; }

        #notification-area {
            position: absolute; bottom: 6rem; left: 24px; right: 24px; z-index: 900; pointer-events: none;
        }
        .notification-item {
            background: rgba(0, 50, 0, 0.8); border: 1px solid #0f0; padding: 5px 10px; margin-bottom: 5px;
            opacity: 1; transform: translateY(0); transition: all 0.2s ease-out;
        }
        .notification-item.fade-out { opacity: 0; transform: translateY(-10px); }

        #sidebar { transition: transform 0.3s ease-in-out; }

        .floating-window {
            width: 280px; height: 180px; background: #000; opacity: 0.95;
            box-shadow: 0 0 15px rgba(0,255,0,0.5); min-width: 200px; min-height: 150px;
            border: 2px solid #0f0;
        }
        .floating-window .drag-handle {
            user-select: none; background: rgba(0,50,0,0.8); cursor: move;
        }
        .floating-window video { width: 100%; height: 100%; object-fit: contain; background: black; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col crt-flicker">
    <div class="scanlines"></div>
    <div id="floating-videos-container"></div>

    <!-- LOGIN SCREEN -->
    <div id="login-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black z-40">
        <pre class="text-xs sm:text-base leading-none mb-8 text-center text-green-500 font-bold">
  ____  _        _    __  __ 
 / ___|| |      / \   \ \/ / 
 \___ \| |     / _ \   \  /  
  ___) | |___ / ___ \  /  \  
 |____/|_____/_/   \_\/_/\_\ 
      OPERATING SYSTEM v5.0
        </pre>
        
        <div class="w-11/12 max-w-md p-6 border-2 border-green-800 bg-black/90 shadow-[0_0_20px_rgba(0,255,0,0.2)]">
            <p id="auth-mode-title" class="mb-2 text-green-400 font-bold text-center text-base sm:text-lg">>> LOG IN REQUIRED</p>
            <div class="h-px w-full bg-green-900 mb-4"></div>
            
            <div class="flex items-center mb-4 text-sm sm:text-base">
                <span class="mr-3 whitespace-nowrap">USER:</span>
                <input type="text" id="username-input" class="flex-1 border-b border-green-800 focus:border-green-500" placeholder="enter_callsign" autocomplete="off" maxlength="12">
            </div>
            
            <div class="flex items-center mb-4 text-sm sm:text-base">
                <span class="mr-3 whitespace-nowrap">PIN:</span>
                <input type="password" id="pin-input" class="flex-1 border-b border-green-800 focus:border-green-500" placeholder="enter_4_digit_pin" autocomplete="off" maxlength="4" pattern="\d*">
            </div>
            
            <p id="login-error" class="text-red-500 mt-2 text-xs sm:text-sm text-center">>> ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ...</p>
            
            <button id="auth-main-btn" class="mt-6 border border-green-600 px-4 py-2 hover:bg-green-600 hover:text-black transition-all w-full text-center font-bold tracking-widest text-sm sm:text-base">
                [ CONNECT ]
            </button>
            
            <button id="auth-switch-btn" class="mt-3 text-xs opacity-70 hover:opacity-100 transition-opacity w-full text-center">
                [ SWITCH TO REGISTER ]
            </button>

            <div class="mt-4 text-[10px] sm:text-xs text-center opacity-50">
                SECURE CONNECTION: <span class="text-green-300">ENCRYPTED</span>
            </div>
        </div>
    </div>

    <!-- MAIN INTERFACE -->
    <div id="main-interface" class="hidden flex-1 flex h-full relative">
        <div id="sidebar-backdrop" onclick="toggleSidebar()" class="hidden md:hidden absolute inset-0 bg-black/50 z-20"></div>

        <div id="sidebar" class="fixed w-64 md:w-72 h-full z-30 border-r-2 border-green-900 flex flex-col bg-black/95 -translate-x-full md:translate-x-0 transition-transform duration-300">
            <div class="p-3 border-b-2 border-green-900 bg-[#051105]">
                <div class="font-bold text-lg sm:text-xl tracking-widest">SLAX_OS</div>
                <div class="text-xs opacity-70 flex justify-between mt-1">
                    <span>NET: ONLINE</span>
                    <span>PING: 24ms</span>
                </div>
            </div>
            
            <div class="p-4 flex-1 overflow-y-auto text-sm sm:text-base">
                <div class="mb-8">
                    <h3 class="text-xs font-bold opacity-60 mb-3 tracking-widest border-b border-green-900/50 pb-1">TEXT_PROTOCOLS</h3>
                    <ul id="text-channels" class="space-y-1">
                        <li onclick="switchChannel('main')" class="cursor-pointer p-2 hover:bg-green-900/20 transition-all channel-active" data-channel="main"># MAIN_HUB</li>
                        <li onclick="switchChannel('offtopic')" class="cursor-pointer p-2 hover:bg-green-900/20 transition-all" data-channel="offtopic"># OFFTOPIC</li>
                        <li onclick="switchChannel('dev')" class="cursor-pointer p-2 hover:bg-green-900/20 transition-all" data-channel="dev"># DEV_LOGS</li>
                    </ul>
                </div>

                <div>
                    <h3 class="text-xs font-bold opacity-60 mb-3 tracking-widest border-b border-green-900/50 pb-1">VOICE_UPLINKS</h3>
                    <ul id="voice-channels" class="space-y-2">
                        <li onclick="handleVoiceAction('lobby')" class="cursor-pointer border border-green-900/50 p-2 hover:border-green-500 transition-all group" data-voice="lobby">
                            <div class="flex justify-between items-center">
                                <span>LOBBY</span>
                                <span class="voice-count text-[10px] bg-green-900 px-1 text-black group-hover:bg-green-500">1</span>
                            </div>
                            <div class="voice-users mt-1 pl-2 text-xs opacity-80 border-l border-green-800 ml-1"></div>
                        </li>
                    </ul>
                    
                    <div id="voice-status-panel" class="hidden mt-6 bg-green-900/10 border border-green-500 p-3">
                        <div class="text-[10px] uppercase tracking-widest mb-1 opacity-70">Текущая Частота</div>
                        <div id="current-voice-name" class="font-bold text-lg mb-2"></div>
                        
                        <div class="flex space-x-2 mb-3">
                            <button id="mic-toggle-btn" onclick="toggleMic()" class="flex-1 bg-green-900/20 border border-green-800 text-green-400 hover:bg-green-800 hover:text-white transition-colors py-1 text-xs sm:text-sm uppercase">
                                MIC: ON
                            </button>
                            <button id="screen-toggle-btn" onclick="toggleScreenShare()" class="flex-1 bg-green-900/20 border border-green-800 text-green-400 hover:bg-green-800 hover:text-white transition-colors py-1 text-xs sm:text-sm uppercase">
                                SCREEN: OFF
                            </button>
                        </div>

                        <button onclick="leaveVoice()" class="w-full bg-red-900/20 border border-red-800 text-red-500 hover:bg-red-900 hover:text-white transition-colors py-1 text-sm uppercase">
                            [ ОТКЛЮЧИТЬ ]
                        </button>
                    </div>
                </div>
            </div>

            <div class="p-3 border-t-2 border-green-900 text-sm bg-black">
                <div class="flex items-center">
                    <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse mr-2"></div>
                    <div>
                        <div id="display-username" class="font-bold tracking-widest">UNKNOWN</div>
                        <div class="text-[10px] opacity-50 font-mono" id="display-uid">SID: ----</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="main-content-area" class="flex-1 flex flex-col relative bg-black md:ml-72 w-full">
            <div class="h-14 border-b border-green-900 flex items-center px-4 md:px-6 justify-between bg-[#050905]">
                <button onclick="toggleSidebar()" class="md:hidden text-green-400 text-lg mr-4">[ МЕНЮ ]</button>
                <span id="channel-title" class="text-lg sm:text-xl font-bold tracking-widest">>> #MAIN_HUB</span>
                <div class="flex items-center space-x-4 text-xs">
                    <span class="hidden md:inline slax-loader opacity-50"></span>
                    <span class="border border-green-700 px-2 py-0.5">REC ●</span>
                </div>
            </div>
            
            <div id="chat-messages" class="flex-1 overflow-y-auto p-4 md:p-6 font-mono space-y-2 text-sm sm:text-base">
                <div class="system-msg border-l-2 border-green-800 pl-2 my-1">>> СИСТЕМА: SLAX KERNEL INITIALIZED...</div>
                <div class="system-msg border-l-2 border-green-800 pl-2 my-1">>> СИСТЕМА: CONNECTING TO FIREBASE NODE [myconsolechat]...</div>
                <div class="system-msg border-l-2 border-green-800 pl-2 my-1">>> СИСТЕМА: WAITING FOR INPUT...</div>
            </div>
            
            <div id="notification-area"></div>

            <div class="p-3 sm:p-4 bg-black border-t border-green-900">
                <div class="flex items-center bg-green-900/10 border border-green-800 p-2 focus-within:border-green-500 transition-colors">
                    <span class="mr-3 text-green-500 font-bold whitespace-nowrap text-sm sm:text-base">root@slax:~#</span>
                    <input type="text" id="message-input" placeholder="execute_command..." autocomplete="off" class="text-sm sm:text-base">
                </div>
                <div class="text-[10px] opacity-30 mt-1 text-right">SLAX_MESSENGER v5.0 // DO NOT DISTRIBUTE</div>
            </div>
        </div>
    </div>
</body>
</html>
